import JSZip from 'jszip';

/**
 * ExportService.js - Generate v1.5 Export Formats
 *
 * This service generates the structured export files from an IdeaSpec:
 * - .cursorrules - AI coding assistant configuration
 * - implementation_plan.md - Detailed development plan
 * - prompt.md - Context dump for AI tools
 * - Download All as .zip
 */

/**
 * Export format generators
 */
export const ExportService = {
  /**
   * Generate ZIP file containing all export artifacts
   * @param {Object} ideaSpec - Complete IdeaSpec object
   * @param {string} blueprint - Compiled markdown blueprint
   * @param {string} htmlMockup - Generated HTML mockup
   * @param {Object} options - Flags for which files to include
   */
  async downloadZip(ideaSpec, blueprint, htmlMockup, options = {}) {
    // Default to all if no options provided
    const includeAll = Object.keys(options).length === 0;
    
    const zip = new JSZip();
    const projectName = (ideaSpec.meta?.name || "project")
      .toLowerCase()
      .replace(/[^a-z0-9]+/g, "-");

    // Add files to zip based on options
    if (includeAll || options.cursorRules) {
        zip.file(".cursorrules", this.toCursorRules(ideaSpec));
    }
    
    if (includeAll || options.implementationPlan) {
        zip.file(`${projectName}-implementation_plan.md`, this.toImplementationPlan(ideaSpec));
    }
    
    if (includeAll || options.promptMd) { // prompt.md isn't inherently in options of ExportModal? Check options keys.
        // ExportModal uses: blueprint, cursorRules, implementationPlan, mockupHtml.
        // prompt.md seems invalid in ExportModal state? 
        // Wait, ExportModal has: blueprint, cursorRules, implementationPlan, mockupHtml.
        // prompt.md is usually part of "context dump". 
        // Let's assume prompt.md is included if 'blueprint' is included or add it to 'implementationPlan'?
        // Actually ExportModal doesn't list 'prompt.md'. 
        // I'll include it if implementationPlan is selected, as a bonus? Or blueprint?
        // Let's include it if 'blueprint' is selected since it's the "context".
        zip.file(`${projectName}-prompt.md`, this.toPromptMd(ideaSpec, blueprint));
        zip.file(`${projectName}-opencode.md`, this.toOpenCodePrompt(ideaSpec));
    }

    if (includeAll || options.blueprint) {
      if (blueprint) {
        zip.file(`${projectName}-BLUEPRINT.md`, blueprint);
      }
      // Also adding the prompts here if blueprint selected, to match above logic if I didn't separate it
    }
    
    if (includeAll || options.mockupHtml) {
      if (htmlMockup) {
        zip.file(`${projectName}-mockup.html`, htmlMockup);
      }
    }

    // Generate and trigger download
    const content = await zip.generateAsync({ type: "blob" });
    const url = URL.createObjectURL(content);
    const a = document.createElement("a");
    a.href = url;
    a.download = `${projectName}-export-package.zip`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  },
  /**
   * Generate .cursorrules file content
   * @param {Object} ideaSpec - Complete IdeaSpec object
   * @returns {string} Content for .cursorrules file
   */
  toCursorRules(ideaSpec) {
    const features = ideaSpec.features || [];
    const techStack = ideaSpec.tech_stack || {};

    return `# .cursorrules
# Auto-generated by Idea Refinery
# Project: ${ideaSpec.meta?.name || "Untitled Project"}

## Stack Configuration
- Frontend: ${techStack.frontend || "React + Vite"}
- Backend: ${techStack.backend || "Node.js"}
- Database: ${techStack.database || "PostgreSQL"}
- Auth: ${techStack.auth || "JWT"}

## Code Style
- Use functional components with hooks
- Prefer TypeScript for type safety
- Use \`lucide-react\` for icons
- Use \`zod\` for all form validation
- STRICT: No \`any\` types unless absolutely necessary
- Prefer named exports over default exports
- Keep components under 200 lines

## Project Context
${ideaSpec.meta?.tagline || "No description provided"}

Target Audience: ${
      ideaSpec.meta?.target_audience?.join(", ") || "General users"
    }

## Features to Implement
${features
  .map((f) => `- ${f.title}: ${f.user_story || "No user story"}`)
  .join("\n")}

## Data Entities
${
  (ideaSpec.data_model || []).map((e) => `- ${e.entity}`).join("\n") ||
  "- (Define your data model)"
}

## Design Guidelines
- Theme: ${ideaSpec.design?.theme_name || "Modern Dark"}
- Primary Color: ${ideaSpec.design?.primary_color || "#d4af37"}
- Mood: ${ideaSpec.design?.mood || "Professional"}
- Mobile-first responsive design
- Accessible (WCAG 2.1 AA)
`;
  },

  /**
   * Generate implementation_plan.md
   * @param {Object} ideaSpec - Complete IdeaSpec object
   * @returns {string} Content for implementation_plan.md
   */
  toImplementationPlan(ideaSpec) {
    const features = ideaSpec.features || [];
    const dataModel = ideaSpec.data_model || [];

    // Group features by complexity
    const byComplexity = {
      high: features.filter((f) => f.complexity === "high"),
      medium: features.filter((f) => f.complexity === "medium"),
      low: features.filter((f) => f.complexity === "low"),
    };

    const renderFeature = (f) => {
      let output = `### ${f.title}\n`;
      if (f.user_story) output += `> ${f.user_story}\n\n`;
      if (f.acceptance_criteria?.length) {
        output += "**Acceptance Criteria:**\n";
        f.acceptance_criteria.forEach((ac) => {
          output += `- [ ] ${ac}\n`;
        });
      }
      return output + "\n";
    };

    return `# Implementation Plan: ${ideaSpec.meta?.name || "Project"}

> ${ideaSpec.meta?.tagline || "No description"}

---

## Phase 1: Core Features (High Priority)

${
  byComplexity.high.length
    ? byComplexity.high.map(renderFeature).join("")
    : "_No high-priority features defined_\n"
}

---

## Phase 2: Secondary Features (Medium Priority)

${
  byComplexity.medium.length
    ? byComplexity.medium.map(renderFeature).join("")
    : "_No medium-priority features defined_\n"
}

---

## Phase 3: Polish & Nice-to-Have (Low Priority)

${
  byComplexity.low.length
    ? byComplexity.low
        .map((f) => `- ${f.title}${f.user_story ? `: ${f.user_story}` : ""}`)
        .join("\n")
    : "_No low-priority features defined_"
}

---

## Data Model

${
  dataModel.length
    ? dataModel
        .map((entity) => {
          let output = `### ${entity.entity}\n\n`;
          if (entity.fields?.length) {
            output += "| Field | Type |\n|-------|------|\n";
            entity.fields.forEach((f) => {
              output += `| ${f.name} | ${f.type} |\n`;
            });
          }
          return output + "\n";
        })
        .join("")
    : "_No data model defined_\n"
}

---

## Tech Stack

| Layer | Technology |
|-------|------------|
| Frontend | ${ideaSpec.tech_stack?.frontend || "TBD"} |
| Backend | ${ideaSpec.tech_stack?.backend || "TBD"} |
| Database | ${ideaSpec.tech_stack?.database || "TBD"} |
| Auth | ${ideaSpec.tech_stack?.auth || "TBD"} |

---

## Verification Plan

### Automated Tests
- [ ] Unit tests for all service functions
- [ ] Integration tests for API endpoints
- [ ] E2E tests for critical user flows

### Manual Verification
- [ ] Responsive layout on mobile (375px) and desktop
- [ ] Auth flow end-to-end
- [ ] Data persistence across sessions
- [ ] Error handling and edge cases
`;
  },

  /**
   * Generate prompt.md (context dump for AI tools)
   * @param {Object} ideaSpec - Complete IdeaSpec object
   * @param {string} [blueprint] - Optional compiled markdown blueprint
   * @returns {string} Content for prompt.md
   */
  toPromptMd(ideaSpec, blueprint = "") {
    const features = ideaSpec.features || [];

    return `# ${ideaSpec.meta?.name || "Project"}

## Project Overview
${ideaSpec.meta?.tagline || "No description provided"}

### Target Audience
${ideaSpec.meta?.target_audience?.join(", ") || "General users"}

### Design Aesthetic
- **Theme:** ${ideaSpec.design?.theme_name || "Modern"}
- **Primary Color:** ${ideaSpec.design?.primary_color || "#d4af37"}
- **Mood:** ${ideaSpec.design?.mood || "Professional"}

---

## Tech Stack
- **Frontend:** ${ideaSpec.tech_stack?.frontend || "React + Vite"}
- **Backend:** ${ideaSpec.tech_stack?.backend || "Node.js"}
- **Database:** ${ideaSpec.tech_stack?.database || "PostgreSQL"}
- **Auth:** ${ideaSpec.tech_stack?.auth || "JWT"}

---

## Core Features

${features
  .map(
    (f) => `### ${f.title}
${f.user_story || ""}

**Complexity:** ${f.complexity || "medium"}

${
  f.acceptance_criteria?.length
    ? `**Acceptance Criteria:**
${f.acceptance_criteria.map((ac) => `- ${ac}`).join("\n")}`
    : ""
}
`,
  )
  .join("\n")}

---

## Data Model

${
  (ideaSpec.data_model || [])
    .map(
      (entity) => `### ${entity.entity}
${
  entity.fields?.map((f) => `- \`${f.name}\`: ${f.type}`).join("\n") ||
  "_No fields defined_"
}
`,
    )
    .join("\n") || "_No data model defined_"
}

---

${
  blueprint
    ? `## Full Blueprint

${blueprint}

---

`
    : ""
}## First Instructions

Set up the project with the specified tech stack:
1. Initialize the project structure
2. Set up the database schema based on the data model
3. Implement authentication
4. Build core features in order of priority (high → medium → low)
5. Add responsive styling using the design tokens
6. Test all user flows end-to-end
`;
  },

  /**
   * Generate prompt optimized for OpenCode CLI
   * @param {Object} ideaSpec - Complete IdeaSpec object
   * @returns {string} Content for opencode-prompt.md
   */
  toOpenCodePrompt(ideaSpec) {
    const prompt = this.toPromptMd(ideaSpec);
    return `Instructions for opencode:
Please build a web application based on the following specifications. 
Use the tech stack mentioned and follow the design aesthetic.
Initialize a new project and implement the core features listed.

${prompt}`;
  },

  /**
   * Download a file with the given content
   * @param {string} filename - Name for the downloaded file
   * @param {string} content - File content
   */
  downloadFile(filename, content) {
    const blob = new Blob([content], { type: "text/plain;charset=utf-8" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  },

  /**
   * Export all formats for an IdeaSpec
   * @param {Object} ideaSpec - Complete IdeaSpec object
   * @param {string} [blueprint] - Optional markdown blueprint
   * @param {string} [htmlMockup] - Optional HTML mockup
   */
  exportAll(ideaSpec, blueprint = "", htmlMockup = "") {
    this.downloadZip(ideaSpec, blueprint, htmlMockup);
  },
};
