# Bolt's Journal

## 2024-05-23 - HistoryView Optimization **Learning:** React components inside large parent components (`App.jsx`) without stable callback references cause frequent re-renders of children, even if those children are heavy lists. **Action:** Always wrap actions passed to heavy list components in `useCallback` and use `React.memo` on the list component and its items. In this case, `HistoryView` was re-rendering on every keystroke in other views because `useProjectState` actions were unstable.

## 2024-05-24 - Input Stability **Learning:** When lifting state up to a common parent (like `App.jsx` via `useProjectState`) for inputs, every keystroke causes a full app re-render. Memoizing static siblings (`Sidebar`, `BottomNav`) is useless if their props (callbacks) are unstable. **Action:** Ensure all event handlers passed to layout components are wrapped in `useCallback` in the custom hook, then `React.memo` the layout components.

## 2024-05-25 - Token Usage Optimization **Learning:** Small utility components that perform seemingly cheap operations (like `JSON.stringify` on a list) can become bottlenecks if they re-render on every keystroke of a parent input. **Action:** Memoize components that perform array/object iteration or serialization, even if they look small. Use `useMemo` for derived statistics to prevent main-thread blocking during high-frequency updates like typing.

## 2024-05-25 - BlueprintStage List Optimization **Learning:** `BlueprintStage` couples high-frequency chat input state with a heavy `framer-motion` list (`FeatureCard`). Without `React.memo`, typing in the chat triggers re-renders of all feature cards, causing input lag. **Action:** Memoize all list item components (`FeatureCard`) that are rendered alongside interactive inputs, especially when using animation libraries like `framer-motion`.

## 2024-05-26 - BlueprintStage Input Isolation **Learning:** Moving the transient `refinementInput` state from the global `useProjectState` hook to local component state in `BlueprintStage` completely eliminated full-app re-renders during typing, solving a significant input lag issue. **Action:** Always check if high-frequency input state needs to be global. If it's only used for a specific action (like sending a message), keep it local and pass the value to the handler.

## 2024-05-26 - QuestionsStage Optimization **Learning:** Inline rendering of inputs in a list (`map`) combined with parent state causes O(N) re-renders for every keystroke. Even simple inputs become laggy with enough items. **Action:** Extract list items into memoized components (`QuestionItem`). Use `useCallback` with functional state updates (`prev => ...`) for the change handler to remove data dependencies, ensuring the handler reference remains stable across updates.

## 2024-05-27 - ContextIndicator Optimization **Learning:** Pure functional components that derive stats from props (like iterating over message history) inside high-frequency inputs (chat) re-calculate on every keystroke. **Action:** Apply `React.memo` to these utility components to prevent unnecessary re-execution of their logic and DOM diffing when the parent re-renders but their data hasn't changed.

## 2024-05-28 - BlueprintStage Debounce Safety **Learning:** Debouncing save operations during high-frequency events (like drag-and-drop) is essential for performance, but creates a risk of data loss if the component unmounts while a save is pending. **Action:** Always implement a 'flush-on-unmount' strategy in the `useEffect` cleanup function to force any pending debounced operations to execute immediately before the component is destroyed.

## 2024-05-29 - History List Optimization **Learning:** Auto-saving mechanisms that trigger full-list re-fetches (via `loadHistory` -> `getRecentConversations`) cause O(N) DB reads and unnecessary React reconciliation on every save. **Action:** Implement optimistic/local state updates in save handlers to avoid re-fetching unchanged data from the database.

## 2024-05-30 - FeatureCard Allocation Optimization **Learning:** Defining constant objects (like style maps) inside list item components (`FeatureCard`) forces unnecessary allocation and garbage collection on every render. In high-frequency updates like drag-and-drop lists, this adds up. **Action:** Move static configuration objects outside the component function scope to ensure they are created only once.

## 2024-05-31 - DiffViewer Memoization **Learning:** Complex diff calculations (O(N) with `JSON.stringify`) inside conditionally rendered components can be expensive if the parent re-renders frequently due to unstable props. Even if hidden, if rendered, they consume main thread. **Action:** Memoize expensive derived state calculations (like diffs) using `useMemo` inside the component, and wrap the component itself in `React.memo` to protect against unstable but functionally equivalent props.
